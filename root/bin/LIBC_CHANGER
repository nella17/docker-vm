#!/usr/bin/env python3
from sys import argv
from subprocess import check_output
import os, re

def main():
    if len(argv) != 3:
        print('Usage : %s [binary] [libc]' % argv[0])
        return
    _,binary,libc = map(os.path.normpath,argv)

    if not os.access(libc,os.R_OK):
        print('Error: Invalid path %s to libc' % libc)
        return
    if not os.access(binary,os.R_OK):
        print('Error: Invalid path %s to binary' % binary)
        return

    new_binary = binary + '.patch'
    if os.access(new_binary,os.R_OK):
        print('Warning: overwrite %s' % new_binary)
    os.system('cp %s %s' % (binary,new_binary))
    if not os.access(new_binary,os.R_OK):
        print('Error: Couldn\'t create patch at %s' % new_binary)
        return

    os.system('chmod +x %s' % libc)
    os.system('chmod +x %s' % new_binary)

    output = check_output(f'./{libc}').decode()
    libc_version = re.findall('stable release version 2.(\d{2})', output)[0]
    output = check_output(['file',binary]).decode()
    v32v64 = re.findall('ELF (\d{2})-bit LSB', output)[0]
    x86x64 = '86' if v32v64 == '32' else v32v64

    ld = '/libc/x%s/Libc%s/ld%s_2.%s.so' % (x86x64, libc_version, v32v64, libc_version)
    if not os.access(ld,os.R_OK):
        print('Warning: match ld not found (%s)' % ld)
    else:
        os.system('patchelf --set-interpreter %s %s' % (ld,new_binary))
    libc_name = 'libc.so.6'
    os.system('patchelf --replace-needed %s ./%s %s' % (libc_name,libc,new_binary))

if __name__ == '__main__':
    main()
